<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bug Detection | Yu Wang&#39;s homepage</title>
    <link>https://itwoi.github.io/tag/bug-detection/</link>
      <atom:link href="https://itwoi.github.io/tag/bug-detection/index.xml" rel="self" type="application/rss+xml" />
    <description>Bug Detection</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Wed, 27 Apr 2016 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://itwoi.github.io/media/icon_hu3111a196585143d4d4672ad8e7e42cb6_90823_512x512_fill_lanczos_center_2.png</url>
      <title>Bug Detection</title>
      <link>https://itwoi.github.io/tag/bug-detection/</link>
    </image>
    
    <item>
      <title>Accerlating Constraint Solving in Symbolic Execution by CNN</title>
      <link>https://itwoi.github.io/project/dlsat/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://itwoi.github.io/project/dlsat/</guid>
      <description>&lt;p&gt;Boolean satisfiability (SAT) is one of the most well-known NP-complete problems and has been extensively studied. State-of-the-art solvers exist and have found a wide range of applications. However, they still do not scale well to formulas with hundreds of variables for uniform 3-SAT problems. To tackle this scalability challenge, we introduce CNNSAT, a fast and accurate statistical decision procedure for SAT based on convolutional neural networks. CNNSATâ€™s effectiveness is due to a precise and compact representation of Boolean formulas. On both real and synthetic formulas, CNNSAT is highly accurate and orders of magnitude faster than the state-of-the-art solvers in predicting satisfiability.&lt;/p&gt;
&lt;p&gt;We also extend CNNSAT to predict the satisfiability of constraints in symbolic execution, which accelerates the constraint solving in symbolic execution, because most unsatisfiable constraints are skipped.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Data Race Detection in Interrupt-driven Programs</title>
      <link>https://itwoi.github.io/project/ytt/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://itwoi.github.io/project/ytt/</guid>
      <description>&lt;p&gt;Interrupt-driven programs are widely deployed in
safety-critical embedded systems to perform hardware and resource
dependent data operation tasks. The frequent uses of
interrupts in these systems can cause data races due
to interactions between application tasks and interrupt handlers.&lt;/p&gt;
&lt;p&gt;We develop an automated framework
that helps in detecting and fixing data races in interrupt-driven
embedded software. It uses a combination of static analysis,
symbolic execution and dynamic simulation to synthesize the
failure-inducing data input and interrupt interleaving schedule.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Semantic Program Embeddings</title>
      <link>https://itwoi.github.io/project/ginn/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://itwoi.github.io/project/ginn/</guid>
      <description>&lt;p&gt;Learning distributed representations of source code has been a challenging task for machine learning models. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. However, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs.&lt;/p&gt;
&lt;p&gt;We present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN.  Unlike the standard GNN, GINN focuses exclusively on intervals (generally manifested in looping construct) for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Preventing Dangling Pointers with Intermediate Pointers</title>
      <link>https://itwoi.github.io/project/dangdone/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://itwoi.github.io/project/dangdone/</guid>
      <description>&lt;p&gt;Existing runtime protection methods that prevent attacks based on dangling pointer incur high runtime overhead and memory overhead.&lt;/p&gt;
&lt;p&gt;We design a lightweight approach to eliminate dangling
pointers during the compilation time.
We first develop a static dangling pointer checker based on Clang to detect potential dangling pointers if the pointers are deallocated but not nullified.
Then, we transform the potential dangling pointers so that
all aliases of a pointer point to the same intermediate pointer.
When all aliases point to the same pointer,
all dangling pointers are eliminated if the intermediate pointer points to null.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scalable, Context-Sensitive, Guarded Data Race Detection</title>
      <link>https://itwoi.github.io/project/guard/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://itwoi.github.io/project/guard/</guid>
      <description>&lt;p&gt;Despite significant progress in recent years, the important problem of practical static race detection remains open.
Previous static techniques either suffer from a high false positive rate due to the compromise of precision, or scalability issues caused by a highly precise analysis.&lt;/p&gt;
&lt;p&gt;In this work, we present a staged approach to resolve this paradox.
It first performs a lightweight context-sensitive data access analysis, based on the value flow of a program,
to identify the candidate data race subpaths instead of the whole program paths.
Second, we employ May-Happen-in-Parallel (MHP) analysis to identify whether two data accesses in a program may execute concurrently.
This stage is scalable, due to the design of the thread flow graph (TFG), that  encodes thread information to query MHP relationship of the subpaths.
Finally, for each subpath whose two data accesses are MHP, we apply heavyweight path-sensitive analysis to verify the feasibility of the data races.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
